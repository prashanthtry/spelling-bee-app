<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Spelling Bee">
    <meta name="theme-color" content="#9333ea">
    <title>Spelling Bee Trainer</title>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-512.svg">
    <link rel="icon" type="image/svg+xml" href="icon-512.svg">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;
        const Volume2 = () => (
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
            </svg>
        );
        const Mic = () => (
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
            </svg>
        );
        const MicOff = () => (
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
            </svg>
        );
        const Check = () => (
            <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
            </svg>
        );
        const X = () => (
            <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
        );
        const RotateCcw = () => (
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
        );
        const Plus = () => (
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
            </svg>
        );
        const Upload = () => (
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
            </svg>
        );
        const Edit2 = () => (
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
            </svg>
        );

        function SpellingBeeApp() {
          const defaultWords = [
            { word: 'beautiful', definition: 'Pleasing to the eye or mind', difficulty: 'medium' },
            { word: 'necessary', definition: 'Required or essential', difficulty: 'medium' },
            { word: 'rhythm', definition: 'A strong, regular repeated pattern of sound', difficulty: 'hard' },
            { word: 'accommodation', definition: 'A place to live or stay', difficulty: 'hard' },
            { word: 'believe', definition: 'To accept something as true', difficulty: 'easy' },
            { word: 'separate', definition: 'To divide or move apart', difficulty: 'medium' },
            { word: 'definitely', definition: 'Without doubt', difficulty: 'medium' },
            { word: 'environment', definition: 'The surroundings in which we live', difficulty: 'medium' },
            { word: 'conscience', definition: 'Inner sense of right and wrong', difficulty: 'hard' },
            { word: 'occurrence', definition: 'An event or incident', difficulty: 'hard' }
          ];

          const [words, setWords] = useState(defaultWords);
          const [currentIndex, setCurrentIndex] = useState(0);
          const [isListening, setIsListening] = useState(false);
          const [spokenText, setSpokenText] = useState('');
          const [interimText, setInterimText] = useState('');
          const [result, setResult] = useState(null);
          const [score, setScore] = useState({ correct: 0, total: 0 });
          const [showAddWord, setShowAddWord] = useState(false);
          const [newWord, setNewWord] = useState({ word: '', definition: '', difficulty: 'medium' });
          const [recognition, setRecognition] = useState(null);
          const [permissionGranted, setPermissionGranted] = useState(false);
          const [uploadStatus, setUploadStatus] = useState('');
          const [isProcessing, setIsProcessing] = useState(false);
          const [showBulkImport, setShowBulkImport] = useState(false);
          const [bulkText, setBulkText] = useState('');

          // Configure PDF.js worker
          useEffect(() => {
            if (window.pdfjsLib) {
              window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            }
          }, []);

          useEffect(() => {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
              const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
              const recognitionInstance = new SpeechRecognition();
              recognitionInstance.continuous = true;
              recognitionInstance.interimResults = true;
              recognitionInstance.lang = 'en-US';

              recognitionInstance.onresult = (event) => {
                let interim = '';
                let final = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                  const transcript = event.results[i][0].transcript;
                  if (event.results[i].isFinal) {
                    final += transcript + ' ';
                  } else {
                    interim += transcript;
                  }
                }
                
                setInterimText(interim);
                
                if (final) {
                  setSpokenText(prev => prev + final);
                }
              };

              recognitionInstance.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                if (event.error === 'not-allowed') {
                  alert('Microphone permission denied. Please allow microphone access and refresh the page.');
                }
                setIsListening(false);
              };

              recognitionInstance.onend = () => {
                if (isListening) {
                  setIsListening(false);
                }
              };

              recognitionInstance.onstart = () => {
                setPermissionGranted(true);
              };

              setRecognition(recognitionInstance);
            }
          }, [isListening]);

          const speakWord = (word, rate = 0.8) => {
            const utterance = new SpeechSynthesisUtterance(word);
            utterance.rate = rate;
            utterance.pitch = 1;
            utterance.volume = 1;
            window.speechSynthesis.speak(utterance);
          };

          const startListening = () => {
            if (recognition) {
              setSpokenText('');
              setInterimText('');
              setResult(null);
              setIsListening(true);
              try {
                recognition.start();
              } catch (error) {
                console.error('Error starting recognition:', error);
              }
            }
          };

          const stopListening = () => {
            if (recognition && isListening) {
              recognition.stop();
              setIsListening(false);
              setInterimText('');
            }
          };

          const submitSpelling = () => {
            stopListening();
            const cleanedSpelling = (spokenText + interimText).toLowerCase().replace(/\s/g, '');
            checkSpelling(cleanedSpelling);
          };

          const checkSpelling = (spoken) => {
            const currentWord = words[currentIndex].word.toLowerCase();
            const isCorrect = spoken === currentWord;
            
            setResult({
              correct: isCorrect,
              spoken: spoken,
              actual: currentWord
            });

            setScore(prev => ({
              correct: prev.correct + (isCorrect ? 1 : 0),
              total: prev.total + 1
            }));
          };

          const nextWord = () => {
            if (currentIndex < words.length - 1) {
              setCurrentIndex(currentIndex + 1);
              setSpokenText('');
              setInterimText('');
              setResult(null);
            }
          };

          const previousWord = () => {
            if (currentIndex > 0) {
              setCurrentIndex(currentIndex - 1);
              setSpokenText('');
              setInterimText('');
              setResult(null);
            }
          };

          const resetQuiz = () => {
            setCurrentIndex(0);
            setSpokenText('');
            setInterimText('');
            setResult(null);
            setScore({ correct: 0, total: 0 });
          };

          const addWord = () => {
            if (newWord.word && newWord.definition) {
              setWords([...words, { ...newWord, word: newWord.word.toLowerCase() }]);
              setNewWord({ word: '', definition: '', difficulty: 'medium' });
              setShowAddWord(false);
            }
          };

          const parsePDF = async (file) => {
            setIsProcessing(true);
            setUploadStatus('Reading PDF...');

            try {
              const arrayBuffer = await file.arrayBuffer();
              const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
              let fullText = '';

              setUploadStatus(`Processing ${pdf.numPages} pages...`);

              for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                fullText += pageText + '\n';
              }

              console.log('Extracted PDF text:', fullText.substring(0, 500)); // Debug log

              // Extract words from the text
              const extractedWords = extractWordsFromText(fullText);
              
              if (extractedWords.length > 0) {
                setWords(prevWords => [...prevWords, ...extractedWords]);
                setUploadStatus(`‚úÖ Success! Added ${extractedWords.length} words from PDF!`);
              } else {
                setUploadStatus(`‚ö†Ô∏è No words found. The PDF may be in an unsupported format. Try adding words manually or check the browser console for details.`);
                console.log('Full extracted text:', fullText);
              }

              setTimeout(() => setUploadStatus(''), 5000);
            } catch (error) {
              console.error('Error parsing PDF:', error);
              setUploadStatus('‚ùå Error reading PDF. Please try again or add words manually.');
              setTimeout(() => setUploadStatus(''), 5000);
            } finally {
              setIsProcessing(false);
            }
          };

          const extractWordsFromText = (text) => {
            const words = [];
            
            // Split by newlines and also by multiple spaces (to handle columns)
            const allText = text.replace(/\s{3,}/g, '\n'); // Convert multiple spaces to newlines
            const lines = allText.split('\n').map(line => line.trim()).filter(line => line);

            // Track words we've already added to avoid duplicates
            const addedWords = new Set();
            
            // Common non-words to filter out
            const skipWords = new Set(['the', 'and', 'or', 'a', 'an', 'to', 'of', 'in', 'for', 'on', 'at', 'by', 'with']);

            for (let line of lines) {
              // Skip very long lines (likely sentences, not word lists)
              if (line.length > 50) continue;
              
              // Try multiple patterns
              
              // Pattern 1: "word - definition" or "word: definition"
              const pattern1 = /^([a-zA-Z]+)\s*[-:‚Äî]\s*(.+)$/;
              // Pattern 2: "word (definition)" 
              const pattern2 = /^([a-zA-Z]+)\s*\((.+)\)$/;
              // Pattern 3: Numbered list "1. word - definition"
              const pattern3 = /^\d+\.\s*([a-zA-Z]+)\s*[-:‚Äî]\s*(.+)$/;
              
              let match = line.match(pattern1) || line.match(pattern2) || line.match(pattern3);
              
              if (match && match[1] && match[2]) {
                const word = match[1].toLowerCase().trim();
                const definition = match[2].trim();
                
                if (word.length >= 3 && word.length <= 20 && definition.length > 5 && !addedWords.has(word) && !skipWords.has(word)) {
                  let difficulty = 'easy';
                  if (word.length > 8) difficulty = 'hard';
                  else if (word.length > 5) difficulty = 'medium';

                  words.push({
                    word: word,
                    definition: definition,
                    difficulty: difficulty
                  });
                  addedWords.add(word);
                }
              } else {
                // No definition - try to extract just words
                // Split the line by spaces to handle multiple words per line
                const potentialWords = line.split(/\s+/);
                
                for (let potentialWord of potentialWords) {
                  // Remove any punctuation except hyphens in the middle of words
                  potentialWord = potentialWord.replace(/^[^a-zA-Z]+|[^a-zA-Z]+$/g, '');
                  
                  // Check if it's a valid single word
                  if (/^[a-zA-Z]+$/.test(potentialWord)) {
                    const word = potentialWord.toLowerCase().trim();
                    
                    // Only add if word is reasonable length (3-20 chars) and not already added
                    if (word.length >= 3 && word.length <= 20 && !addedWords.has(word) && !skipWords.has(word)) {
                      // Determine difficulty based on word length
                      let difficulty = 'easy';
                      if (word.length > 8) difficulty = 'hard';
                      else if (word.length > 5) difficulty = 'medium';

                      words.push({
                        word: word,
                        definition: `Practice spelling: ${word}`,
                        difficulty: difficulty
                      });
                      addedWords.add(word);
                    }
                  }
                }
              }
            }

            return words;
          };

          const handleFileUpload = (event) => {
            const file = event.target.files[0];
            if (file && file.type === 'application/pdf') {
              parsePDF(file);
            } else {
              setUploadStatus('‚ùå Please upload a PDF file');
              setTimeout(() => setUploadStatus(''), 3000);
            }
            // Reset input
            event.target.value = '';
          };

          const handleBulkImport = () => {
            if (!bulkText.trim()) {
              setUploadStatus('‚ö†Ô∏è Please enter some words first');
              setTimeout(() => setUploadStatus(''), 3000);
              return;
            }

            const extractedWords = extractWordsFromText(bulkText);
            
            if (extractedWords.length > 0) {
              setWords(prevWords => [...prevWords, ...extractedWords]);
              setUploadStatus(`‚úÖ Added ${extractedWords.length} words!`);
              setBulkText('');
              setShowBulkImport(false);
            } else {
              setUploadStatus('‚ö†Ô∏è No valid words found. Make sure words are on separate lines.');
            }

            setTimeout(() => setUploadStatus(''), 5000);
          };

          const currentWord = words[currentIndex];
          const progress = ((currentIndex + 1) / words.length) * 100;

          if (!recognition) {
            return (
              <div className="min-h-screen bg-gradient-to-br from-purple-50 to-blue-50 flex items-center justify-center p-4">
                <div className="bg-white rounded-lg shadow-lg p-8 max-w-md text-center">
                  <X />
                  <h2 className="text-2xl font-bold text-gray-800 mb-2">Speech Recognition Not Supported</h2>
                  <p className="text-gray-600">
                    Your browser doesn't support speech recognition. Please use Chrome, Edge, or Safari.
                  </p>
                </div>
              </div>
            );
          }

          return (
            <div className="min-h-screen bg-gradient-to-br from-purple-50 to-blue-50 p-4">
              <div className="max-w-4xl mx-auto">
                <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                  <div className="flex items-center justify-between mb-4 flex-wrap gap-2">
                    <h1 className="text-3xl font-bold text-purple-600">üêù Spelling Bee Trainer</h1>
                    <div className="flex gap-2 flex-wrap">
                      <label className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition cursor-pointer">
                        <Upload />
                        Upload PDF
                        <input
                          type="file"
                          accept=".pdf"
                          onChange={handleFileUpload}
                          className="hidden"
                          disabled={isProcessing}
                        />
                      </label>
                      <button
                        onClick={() => setShowBulkImport(!showBulkImport)}
                        className="flex items-center gap-2 px-4 py-2 bg-orange-500 text-white rounded-lg hover:bg-orange-600 transition"
                      >
                        <Edit2 />
                        Import Text
                      </button>
                      <button
                        onClick={() => setShowAddWord(!showAddWord)}
                        className="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition"
                      >
                        <Plus />
                        Add Word
                      </button>
                    </div>
                  </div>

                  {uploadStatus && (
                    <div className={`mb-4 p-3 rounded-lg ${
                      uploadStatus.includes('‚úÖ') ? 'bg-green-50 text-green-700' :
                      uploadStatus.includes('‚ùå') || uploadStatus.includes('‚ö†Ô∏è') ? 'bg-red-50 text-red-700' :
                      'bg-blue-50 text-blue-700'
                    }`}>
                      {uploadStatus}
                    </div>
                  )}

                  <div className="flex items-center justify-between text-sm">
                    <div className="flex items-center gap-4">
                      <span className="text-gray-600">
                        Word {currentIndex + 1} of {words.length}
                      </span>
                      <span className="text-green-600 font-semibold">
                        Score: {score.correct}/{score.total}
                        {score.total > 0 && ` (${Math.round((score.correct / score.total) * 100)}%)`}
                      </span>
                    </div>
                    <button
                      onClick={resetQuiz}
                      className="flex items-center gap-1 text-purple-600 hover:text-purple-700"
                    >
                      <RotateCcw />
                      Reset
                    </button>
                  </div>

                  <div className="w-full bg-gray-200 rounded-full h-2 mt-4">
                    <div
                      className="bg-purple-600 h-2 rounded-full transition-all duration-300"
                      style={{ width: `${progress}%` }}
                    />
                  </div>
                </div>

                {showAddWord && (
                  <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                    <h3 className="text-xl font-bold text-gray-800 mb-4">Add New Word</h3>
                    <div className="space-y-4">
                      <input
                        type="text"
                        placeholder="Word"
                        value={newWord.word}
                        onChange={(e) => setNewWord({ ...newWord, word: e.target.value })}
                        className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent"
                      />
                      <input
                        type="text"
                        placeholder="Definition"
                        value={newWord.definition}
                        onChange={(e) => setNewWord({ ...newWord, definition: e.target.value })}
                        className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent"
                      />
                      <select
                        value={newWord.difficulty}
                        onChange={(e) => setNewWord({ ...newWord, difficulty: e.target.value })}
                        className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent"
                      >
                        <option value="easy">Easy</option>
                        <option value="medium">Medium</option>
                        <option value="hard">Hard</option>
                      </select>
                      <div className="flex gap-2">
                        <button
                          onClick={addWord}
                          className="flex-1 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition"
                        >
                          Add Word
                        </button>
                        <button
                          onClick={() => setShowAddWord(false)}
                          className="flex-1 px-4 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 transition"
                        >
                          Cancel
                        </button>
                      </div>
                    </div>
                  </div>
                )}

                {showBulkImport && (
                  <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                    <h3 className="text-xl font-bold text-gray-800 mb-4">Import Words from Text</h3>
                    <p className="text-sm text-gray-600 mb-3">
                      Paste your word list below. Each word should be on a new line. You can include definitions like "word - definition" or just plain words.
                    </p>
                    <textarea
                      value={bulkText}
                      onChange={(e) => setBulkText(e.target.value)}
                      placeholder="Example:
heap
ladder
bedroom
branch
letter

Or with definitions:
beautiful - pleasing to the eye
necessary - required or essential"
                      className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-orange-500 focus:border-transparent font-mono text-sm"
                      rows="10"
                    />
                    <div className="flex gap-2 mt-4">
                      <button
                        onClick={handleBulkImport}
                        className="flex-1 px-4 py-2 bg-orange-500 text-white rounded-lg hover:bg-orange-600 transition"
                      >
                        Import Words
                      </button>
                      <button
                        onClick={() => {
                          setShowBulkImport(false);
                          setBulkText('');
                        }}
                        className="flex-1 px-4 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 transition"
                      >
                        Cancel
                      </button>
                    </div>
                  </div>
                )}

                <div className="bg-white rounded-lg shadow-lg p-8">
                  <div className="text-center mb-8">
                    <div className="inline-block px-4 py-1 bg-purple-100 text-purple-700 rounded-full text-sm font-semibold mb-4">
                      {currentWord.difficulty.toUpperCase()}
                    </div>
                    <h2 className="text-2xl font-semibold text-gray-700 mb-4">
                      {currentWord.definition}
                    </h2>
                    <button
                      onClick={() => speakWord(currentWord.word)}
                      className="inline-flex items-center gap-2 px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition text-lg font-semibold"
                    >
                      <Volume2 />
                      Hear the Word
                    </button>
                    <button
                      onClick={() => speakWord(currentWord.word, 0.5)}
                      className="ml-2 px-4 py-3 bg-blue-400 text-white rounded-lg hover:bg-blue-500 transition text-sm"
                    >
                      Slower
                    </button>
                  </div>

                  <div className="mb-8">
                    <div className="text-center mb-4">
                      <p className="text-gray-600 mb-4">
                        Click the microphone and spell the word letter by letter out loud
                      </p>
                      <div className="flex gap-3 justify-center flex-wrap">
                        <button
                          onClick={isListening ? stopListening : startListening}
                          className={`inline-flex items-center gap-2 px-8 py-4 rounded-lg text-white font-semibold transition text-lg ${
                            isListening
                              ? 'bg-red-500 hover:bg-red-600'
                              : 'bg-purple-500 hover:bg-purple-600'
                          }`}
                        >
                          {isListening ? (
                            <>
                              <MicOff />
                              Stop Recording
                            </>
                          ) : (
                            <>
                              <Mic />
                              Start Spelling
                            </>
                          )}
                        </button>
                        
                        {(spokenText || interimText) && (
                          <button
                            onClick={submitSpelling}
                            className="inline-flex items-center gap-2 px-8 py-4 bg-green-500 text-white rounded-lg hover:bg-green-600 transition text-lg font-semibold"
                          >
                            <Check />
                            Submit Answer
                          </button>
                        )}
                      </div>
                    </div>

                    {isListening && (
                      <div className="bg-red-50 border-2 border-red-500 rounded-lg p-4 mb-4">
                        <div className="flex items-center justify-center gap-3">
                          <div className="w-3 h-3 bg-red-500 rounded-full animate-pulse"></div>
                          <p className="text-red-700 font-semibold">üé§ Listening... Speak clearly!</p>
                        </div>
                      </div>
                    )}

                    {(spokenText || interimText) && (
                      <div className="bg-blue-50 rounded-lg p-4 mb-4 border-2 border-blue-300">
                        <p className="text-sm text-blue-600 mb-2 font-semibold">What I'm hearing:</p>
                        <p className="text-2xl font-mono font-bold text-blue-800 tracking-wide">
                          {spokenText}
                          <span className="text-blue-400">{interimText}</span>
                        </p>
                        <p className="text-sm text-blue-600 mt-2">
                          {isListening ? 'üî¥ Still listening...' : '‚úì Recording stopped - click Submit Answer'}
                        </p>
                      </div>
                    )}

                    {result && (
                      <div
                        className={`rounded-lg p-6 ${
                          result.correct
                            ? 'bg-green-50 border-2 border-green-500'
                            : 'bg-red-50 border-2 border-red-500'
                        }`}
                      >
                        <div className="flex items-center gap-3 mb-3">
                          {result.correct ? (
                            <>
                              <Check />
                              <h3 className="text-2xl font-bold text-green-700">Correct! üéâ</h3>
                            </>
                          ) : (
                            <>
                              <X />
                              <h3 className="text-2xl font-bold text-red-700">Not Quite</h3>
                            </>
                          )}
                        </div>
                        <div className="space-y-2">
                          <p className="text-gray-700">
                            <span className="font-semibold">You spelled:</span>{' '}
                            <span className="font-mono">{result.spoken.toUpperCase()}</span>
                          </p>
                          {!result.correct && (
                            <p className="text-gray-700">
                              <span className="font-semibold">Correct spelling:</span>{' '}
                              <span className="font-mono text-green-700 font-bold">
                                {result.actual.toUpperCase()}
                              </span>
                            </p>
                          )}
                        </div>
                      </div>
                    )}
                  </div>

                  <div className="flex gap-4">
                    <button
                      onClick={previousWord}
                      disabled={currentIndex === 0}
                      className="flex-1 px-6 py-3 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 transition disabled:opacity-50 disabled:cursor-not-allowed font-semibold"
                    >
                      ‚Üê Previous
                    </button>
                    <button
                      onClick={nextWord}
                      disabled={currentIndex === words.length - 1}
                      className="flex-1 px-6 py-3 bg-purple-500 text-white rounded-lg hover:bg-purple-600 transition disabled:opacity-50 disabled:cursor-not-allowed font-semibold"
                    >
                      Next ‚Üí
                    </button>
                  </div>

                  {currentIndex === words.length - 1 && result && (
                    <div className="mt-6 bg-yellow-50 border-2 border-yellow-400 rounded-lg p-4 text-center">
                      <p className="text-yellow-800 font-semibold">
                        üéä You've completed all words! Final Score: {score.correct}/{score.total}
                      </p>
                    </div>
                  )}
                </div>

                <div className="mt-6 bg-white rounded-lg shadow-lg p-6">
                  <h3 className="text-lg font-bold text-gray-800 mb-3">How to Use:</h3>
                  <ol className="space-y-2 text-gray-700">
                    <li>1. Click "Hear the Word" to listen to the pronunciation</li>
                    <li>2. Click "Start Spelling" - the microphone will turn on</li>
                    <li>3. Spell the word out loud letter by letter (e.g., "B E A U T I F U L")</li>
                    <li>4. You'll see what the app hears in real-time in the blue box</li>
                    <li>5. When done, click "Stop Recording" then "Submit Answer"</li>
                    <li>6. Get instant feedback and move to the next word!</li>
                    <li>7. Add your own custom words using the "Add Word" button</li>
                    <li>8. <strong>Upload PDF</strong> to automatically extract words from study materials!</li>
                  </ol>
                  <div className="mt-4 bg-yellow-50 border border-yellow-300 rounded-lg p-3">
                    <p className="text-sm text-yellow-800">
                      <strong>üí° Tip:</strong> Make sure to allow microphone access when prompted. Speak clearly and pause slightly between each letter!
                    </p>
                  </div>
                  <div className="mt-3 bg-blue-50 border border-blue-300 rounded-lg p-3">
                    <p className="text-sm text-blue-800">
                      <strong>üìÑ PDF Formats Supported:</strong><br/>
                      <strong>With definitions:</strong><br/>
                      ‚Ä¢ "beautiful - pleasing to the eye"<br/>
                      ‚Ä¢ "necessary: required or essential"<br/>
                      ‚Ä¢ "1. rhythm - a repeated pattern"<br/>
                      <strong>Word lists only (like spelling bee lists):</strong><br/>
                      ‚Ä¢ sky<br/>
                      ‚Ä¢ wow<br/>
                      ‚Ä¢ beautiful
                    </p>
                  </div>
                </div>
              </div>
            </div>
          );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<SpellingBeeApp />);
    </script>
</body>
</html>
